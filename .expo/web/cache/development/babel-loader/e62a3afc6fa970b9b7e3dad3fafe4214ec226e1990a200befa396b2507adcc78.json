{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport { Rect, Size, Point, Placement } from \"./Types\";\nimport { getBorderRadius } from \"./Utility\";\nimport { POPOVER_MARGIN } from \"./Constants\";\nvar Geometry = function () {\n  function Geometry(_a) {\n    var popoverOrigin = _a.popoverOrigin,\n      anchorPoint = _a.anchorPoint,\n      placement = _a.placement,\n      forcedContentSize = _a.forcedContentSize,\n      viewLargerThanDisplayArea = _a.viewLargerThanDisplayArea;\n    this.popoverOrigin = popoverOrigin;\n    this.anchorPoint = anchorPoint;\n    this.placement = placement;\n    this.forcedContentSize = forcedContentSize;\n    this.viewLargerThanDisplayArea = viewLargerThanDisplayArea;\n  }\n  Geometry.equals = function (a, b) {\n    var _a, _b, _c, _d;\n    return a.popoverOrigin.equals(b.popoverOrigin) && a.anchorPoint.equals(b.anchorPoint) && a.placement === b.placement && a.forcedContentSize.equals(b.forcedContentSize) && ((_a = a.viewLargerThanDisplayArea) === null || _a === void 0 ? void 0 : _a.width) === ((_b = b.viewLargerThanDisplayArea) === null || _b === void 0 ? void 0 : _b.width) && ((_c = a.viewLargerThanDisplayArea) === null || _c === void 0 ? void 0 : _c.height) === ((_d = b.viewLargerThanDisplayArea) === null || _d === void 0 ? void 0 : _d.height);\n  };\n  return Geometry;\n}();\nexport { Geometry };\nexport function computeGeometry(options) {\n  var requestedContentSize = options.requestedContentSize,\n    placement = options.placement,\n    displayArea = options.displayArea,\n    debug = options.debug,\n    popoverStyle = options.popoverStyle,\n    arrowShift = options.arrowShift,\n    popoverShift = options.popoverShift,\n    arrowSize = options.arrowSize;\n  var newGeom = null;\n  var fromRect = options.fromRect ? Rect.clone(options.fromRect) : null;\n  if (fromRect && options.fromRect instanceof Rect) {\n    var borderRadius = getBorderRadius(popoverStyle);\n    var selectedPlacement = Array.isArray(placement) ? placement[0] : placement;\n    if (Array.isArray(placement)) {\n      var spaceList = generateSpaceList({\n        fromRect: fromRect,\n        displayArea: displayArea,\n        requestedContentSize: requestedContentSize,\n        arrowSize: arrowSize\n      });\n      var bestPlacements_1 = calculateBestPlacements(spaceList);\n      var bestProvidedPlacement = placement.filter(function (p) {\n        return p === Placement.AUTO || p === Placement.FLOATING || bestPlacements_1.includes(p);\n      })[0];\n      if (bestProvidedPlacement) selectedPlacement = bestProvidedPlacement;\n    }\n    switch (selectedPlacement) {\n      case Placement.TOP:\n        newGeom = computeTopGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.BOTTOM:\n        newGeom = computeBottomGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.LEFT:\n        newGeom = computeLeftGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.RIGHT:\n        newGeom = computeRightGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n        break;\n      case Placement.FLOATING:\n        newGeom = null;\n        break;\n      default:\n        newGeom = computeAutoGeometry(__assign(__assign({}, options), {\n          fromRect: fromRect,\n          borderRadius: borderRadius\n        }));\n    }\n    debug('computeGeometry - initial chosen geometry', newGeom);\n    if (newGeom && (newGeom.viewLargerThanDisplayArea.width || newGeom.viewLargerThanDisplayArea.height)) {\n      var fromRectHeightVisible = fromRect.y < displayArea.y ? fromRect.height - (displayArea.y - fromRect.y) : displayArea.y + displayArea.height - fromRect.y;\n      if (fromRect.width > requestedContentSize.width && fromRectHeightVisible > requestedContentSize.height) {\n        var preferredX = Math.max(fromRect.x + 10, fromRect.x + (fromRect.width - requestedContentSize.width) / 2);\n        var preferredY = Math.max(fromRect.y + 10, fromRect.y + (fromRect.height - requestedContentSize.height) / 2);\n        var constrainedX = Math.max(preferredX, displayArea.x);\n        if (constrainedX + requestedContentSize.width > displayArea.x + displayArea.width) constrainedX = displayArea.x + displayArea.width - requestedContentSize.width;\n        var constrainedY = Math.max(preferredY, displayArea.y);\n        if (constrainedY + requestedContentSize.height > displayArea.y + displayArea.height) constrainedY = displayArea.y + displayArea.height - requestedContentSize.height;\n        var forcedContentSize = new Size(Math.min(fromRect.width - 20, displayArea.width), Math.min(fromRect.height - 20, displayArea.height));\n        debug('computeGeometry - showing inside anchor');\n        newGeom = new Geometry({\n          popoverOrigin: new Point(constrainedX, constrainedY),\n          anchorPoint: new Point(fromRect.x + fromRect.width / 2, fromRect.y + fromRect.height / 2),\n          placement: Placement.FLOATING,\n          forcedContentSize: forcedContentSize,\n          viewLargerThanDisplayArea: {\n            width: requestedContentSize.width > forcedContentSize.width,\n            height: requestedContentSize.height > forcedContentSize.height\n          }\n        });\n      } else if (placement === Placement.AUTO && (newGeom.viewLargerThanDisplayArea.width && [Placement.RIGHT, Placement.LEFT].includes(newGeom.placement) || newGeom.viewLargerThanDisplayArea.height && [Placement.TOP, Placement.BOTTOM].includes(newGeom.placement))) {\n        newGeom = null;\n      }\n    }\n  }\n  if (!newGeom) {\n    var minY = displayArea.y;\n    var minX = displayArea.x;\n    var preferedY = (displayArea.height - requestedContentSize.height) / 2 + displayArea.y;\n    var preferedX = (displayArea.width - requestedContentSize.width) / 2 + displayArea.x;\n    debug('computeGeometry - showing floating');\n    newGeom = new Geometry({\n      popoverOrigin: new Point(Math.max(minX, preferedX), Math.max(minY, preferedY)),\n      anchorPoint: new Point(displayArea.width / 2 + displayArea.x, displayArea.height / 2 + displayArea.y),\n      placement: Placement.FLOATING,\n      forcedContentSize: new Size(displayArea.width, displayArea.height),\n      viewLargerThanDisplayArea: {\n        width: preferedX < minX - 1,\n        height: preferedY < minY - 1\n      }\n    });\n    if (!newGeom.viewLargerThanDisplayArea.width && (popoverShift === null || popoverShift === void 0 ? void 0 : popoverShift.x)) {\n      debug('computeGeometry - applying popoverShift.x', popoverShift.x);\n      var horizontalMargin = (displayArea.width - requestedContentSize.width) / 2;\n      newGeom.popoverOrigin.x += popoverShift.x * horizontalMargin;\n      newGeom.anchorPoint.x = newGeom.popoverOrigin.x + requestedContentSize.width / 2;\n    }\n    if (!newGeom.viewLargerThanDisplayArea.height && (popoverShift === null || popoverShift === void 0 ? void 0 : popoverShift.y)) {\n      debug('computeGeometry - applying popoverShift.y', popoverShift.y);\n      var verticalMargin = (displayArea.height - requestedContentSize.height) / 2;\n      newGeom.popoverOrigin.y += popoverShift.y * verticalMargin;\n      newGeom.anchorPoint.y = newGeom.popoverOrigin.y + requestedContentSize.height / 2;\n    }\n  }\n  if (arrowShift && fromRect) {\n    if (newGeom.placement === Placement.BOTTOM || newGeom.placement === Placement.TOP) newGeom.anchorPoint.x += arrowShift * 0.5 * fromRect.width;else newGeom.anchorPoint.y += arrowShift * 0.5 * fromRect.height;\n  }\n  debug('computeGeometry - final chosen geometry', newGeom);\n  return newGeom;\n}\nfunction computeTopGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    arrowSize = _a.arrowSize,\n    borderRadius = _a.borderRadius,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y + POPOVER_MARGIN, displayArea.width - POPOVER_MARGIN * 2, displayArea.height);\n  if (offset) fromRect.y -= offset;\n  var minY = displayArea.y;\n  var maxY = displayArea.y + displayArea.height;\n  var preferredY = fromRect.y - requestedContentSize.height - arrowSize.height;\n  var forcedContentSize = new Size(displayArea.width, fromRect.y - arrowSize.height - displayArea.y);\n  var viewLargerThanDisplayArea = {\n    height: preferredY <= minY - 1,\n    width: requestedContentSize.width >= displayArea.width + 1\n  };\n  var viewWidth = viewLargerThanDisplayArea.width ? forcedContentSize.width : requestedContentSize.width;\n  var maxX = displayArea.x + displayArea.width - viewWidth;\n  var minX = displayArea.x;\n  var preferredX = fromRect.x + (fromRect.width - viewWidth) / 2;\n  var popoverOrigin = new Point(Math.min(maxX, Math.max(minX, preferredX)), Math.min(maxY, Math.max(minY, preferredY)));\n  var anchorPoint = new Point(fromRect.x + fromRect.width / 2, fromRect.y);\n  anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + arrowSize.width / 2 + borderRadius);\n  anchorPoint.x = Math.min(anchorPoint.x, displayArea.x + displayArea.width - arrowSize.width / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.TOP,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction computeBottomGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    arrowSize = _a.arrowSize,\n    borderRadius = _a.borderRadius,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y, displayArea.width - POPOVER_MARGIN * 2, displayArea.height - POPOVER_MARGIN);\n  if (offset) fromRect.y += offset;\n  var minY = displayArea.y;\n  var maxY = displayArea.y + displayArea.height;\n  var preferedY = fromRect.y + fromRect.height;\n  var forcedContentSize = new Size(displayArea.width, displayArea.y + displayArea.height - preferedY);\n  var viewLargerThanDisplayArea = {\n    height: preferedY + requestedContentSize.height >= displayArea.y + displayArea.height + 1,\n    width: requestedContentSize.width >= displayArea.width + 1\n  };\n  var viewWidth = viewLargerThanDisplayArea.width ? forcedContentSize.width : requestedContentSize.width;\n  var maxX = displayArea.x + displayArea.width - viewWidth;\n  var minX = displayArea.x;\n  var preferedX = fromRect.x + (fromRect.width - viewWidth) / 2;\n  var popoverOrigin = new Point(Math.min(maxX, Math.max(minX, preferedX)), Math.min(maxY, Math.max(minY, preferedY)));\n  var anchorPoint = new Point(fromRect.x + fromRect.width / 2, fromRect.y + fromRect.height);\n  anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + arrowSize.width / 2 + borderRadius);\n  anchorPoint.x = Math.min(anchorPoint.x, displayArea.x + displayArea.width - arrowSize.width / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.BOTTOM,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction computeLeftGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    borderRadius = _a.borderRadius,\n    arrowSize = _a.arrowSize,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x + POPOVER_MARGIN, displayArea.y + POPOVER_MARGIN, displayArea.width, displayArea.height - POPOVER_MARGIN * 2);\n  if (offset) fromRect.x -= offset;\n  var forcedContentSize = new Size(fromRect.x - displayArea.x - arrowSize.width, displayArea.height);\n  var viewLargerThanDisplayArea = {\n    height: requestedContentSize.height >= displayArea.height + 1,\n    width: requestedContentSize.width >= fromRect.x - displayArea.x - arrowSize.width + 1\n  };\n  var viewWidth = viewLargerThanDisplayArea.width ? forcedContentSize.width : requestedContentSize.width;\n  var viewHeight = viewLargerThanDisplayArea.height ? forcedContentSize.height : requestedContentSize.height;\n  var preferedX = fromRect.x - viewWidth - arrowSize.height;\n  var minX = displayArea.x;\n  var maxX = displayArea.x + displayArea.width;\n  var preferedY = fromRect.y + (fromRect.height - viewHeight) / 2;\n  var minY = displayArea.y;\n  var maxY = displayArea.height - viewHeight + displayArea.y;\n  var popoverOrigin = new Point(Math.min(Math.max(minX, preferedX), maxX), Math.min(Math.max(minY, preferedY), maxY));\n  var anchorPoint = new Point(fromRect.x, fromRect.y + fromRect.height / 2);\n  anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + arrowSize.height / 2 + borderRadius);\n  anchorPoint.y = Math.min(anchorPoint.y, displayArea.y + displayArea.height - arrowSize.height / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.LEFT,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction computeRightGeometry(_a) {\n  var displayArea = _a.displayArea,\n    fromRect = _a.fromRect,\n    requestedContentSize = _a.requestedContentSize,\n    arrowSize = _a.arrowSize,\n    borderRadius = _a.borderRadius,\n    offset = _a.offset;\n  displayArea = new Rect(displayArea.x, displayArea.y + POPOVER_MARGIN, displayArea.width - POPOVER_MARGIN, displayArea.height - POPOVER_MARGIN * 2);\n  if (offset) fromRect.x += offset;\n  var horizontalSpace = displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width;\n  var forcedContentSize = new Size(horizontalSpace, displayArea.height);\n  var viewLargerThanDisplayArea = {\n    height: requestedContentSize.height >= displayArea.height + 1,\n    width: requestedContentSize.width >= horizontalSpace + 1\n  };\n  var viewHeight = viewLargerThanDisplayArea.height ? forcedContentSize.height : requestedContentSize.height;\n  var preferedX = fromRect.x + fromRect.width;\n  var minX = displayArea.x;\n  var maxX = displayArea.x + displayArea.width;\n  var preferedY = fromRect.y + (fromRect.height - viewHeight) / 2;\n  var minY = displayArea.y;\n  var maxY = displayArea.height - viewHeight + displayArea.y;\n  var popoverOrigin = new Point(Math.min(Math.max(minX, preferedX), maxX), Math.min(Math.max(minY, preferedY), maxY));\n  var anchorPoint = new Point(fromRect.x + fromRect.width, fromRect.y + fromRect.height / 2.0);\n  anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + arrowSize.height / 2 + borderRadius);\n  anchorPoint.y = Math.min(anchorPoint.y, displayArea.y + displayArea.height - arrowSize.height / 2 - borderRadius);\n  return new Geometry({\n    popoverOrigin: popoverOrigin,\n    anchorPoint: anchorPoint,\n    placement: Placement.RIGHT,\n    forcedContentSize: forcedContentSize,\n    viewLargerThanDisplayArea: viewLargerThanDisplayArea\n  });\n}\nfunction generateSpaceList(_a) {\n  var _b;\n  var fromRect = _a.fromRect,\n    displayArea = _a.displayArea,\n    arrowSize = _a.arrowSize,\n    requestedContentSize = _a.requestedContentSize;\n  function generateOption(props) {\n    return __assign(__assign({}, props), {\n      fits: props.sizeAvailable >= props.sizeRequested,\n      extraSpace: props.sizeAvailable - props.sizeRequested\n    });\n  }\n  return _b = {}, _b[Placement.LEFT] = generateOption({\n    sizeAvailable: fromRect.x - displayArea.x - arrowSize.width,\n    sizeRequested: requestedContentSize.width\n  }), _b[Placement.RIGHT] = generateOption({\n    sizeAvailable: displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width,\n    sizeRequested: requestedContentSize.width\n  }), _b[Placement.TOP] = generateOption({\n    sizeAvailable: fromRect.y - displayArea.y - arrowSize.width,\n    sizeRequested: requestedContentSize.height\n  }), _b[Placement.BOTTOM] = generateOption({\n    sizeAvailable: displayArea.y + displayArea.height - (fromRect.y + fromRect.height) - arrowSize.width,\n    sizeRequested: requestedContentSize.height\n  }), _b;\n}\nfunction computeAutoGeometry(options) {\n  var displayArea = options.displayArea,\n    requestedContentSize = options.requestedContentSize,\n    fromRect = options.fromRect,\n    previousPlacement = options.previousPlacement,\n    debug = options.debug,\n    arrowSize = options.arrowSize;\n  if (previousPlacement === Placement.LEFT || previousPlacement === Placement.RIGHT) {\n    var geom = previousPlacement === Placement.LEFT ? computeLeftGeometry(options) : computeRightGeometry(options);\n    debug('computeAutoGeometry - Left/right tryping to keep same, geometry', geom);\n    if (!geom.viewLargerThanDisplayArea.width) return geom;\n  }\n  if (previousPlacement === Placement.TOP || previousPlacement === Placement.BOTTOM) {\n    var geom = previousPlacement === Placement.TOP ? computeTopGeometry(options) : computeBottomGeometry(options);\n    debug('computeAutoGeometry - Top/bottom tryping to keep same, geometry', geom);\n    if (!geom.viewLargerThanDisplayArea.height) return geom;\n  }\n  debug('computeAutoGeometry - displayArea', displayArea);\n  debug('computeAutoGeometry - fromRect', fromRect);\n  var spaceList = generateSpaceList({\n    fromRect: fromRect,\n    displayArea: displayArea,\n    arrowSize: arrowSize,\n    requestedContentSize: requestedContentSize\n  });\n  debug('computeAutoGeometry - List of available space', spaceList);\n  var bestPlacementPosition = calculateBestPlacements(spaceList)[0];\n  debug('computeAutoGeometry - Found best postition for placement', bestPlacementPosition);\n  switch (bestPlacementPosition) {\n    case Placement.LEFT:\n      return computeLeftGeometry(options);\n    case Placement.RIGHT:\n      return computeRightGeometry(options);\n    case Placement.BOTTOM:\n      return computeBottomGeometry(options);\n    case Placement.TOP:\n      return computeTopGeometry(options);\n    default:\n      return null;\n  }\n}\nfunction calculateBestPlacements(spaceList) {\n  return Object.keys(spaceList).filter(function (o) {\n    var _a;\n    return (_a = spaceList[o]) === null || _a === void 0 ? void 0 : _a.fits;\n  }).sort(function (a, b) {\n    var _a, _b, _c, _d;\n    return ((_b = (_a = spaceList[b]) === null || _a === void 0 ? void 0 : _a.extraSpace) !== null && _b !== void 0 ? _b : 0) - ((_d = (_c = spaceList[a]) === null || _c === void 0 ? void 0 : _c.extraSpace) !== null && _d !== void 0 ? _d : 0);\n  });\n}","map":{"version":3,"names":["Rect","Size","Point","Placement","getBorderRadius","POPOVER_MARGIN","Geometry","_a","popoverOrigin","anchorPoint","placement","forcedContentSize","viewLargerThanDisplayArea","equals","a","b","width","_b","_c","height","_d","computeGeometry","options","requestedContentSize","displayArea","debug","popoverStyle","arrowShift","popoverShift","arrowSize","newGeom","fromRect","clone","borderRadius","selectedPlacement","Array","isArray","spaceList","generateSpaceList","bestPlacements_1","calculateBestPlacements","bestProvidedPlacement","filter","p","AUTO","FLOATING","includes","TOP","computeTopGeometry","__assign","BOTTOM","computeBottomGeometry","LEFT","computeLeftGeometry","RIGHT","computeRightGeometry","computeAutoGeometry","fromRectHeightVisible","y","preferredX","Math","max","x","preferredY","constrainedX","constrainedY","min","minY","minX","preferedY","preferedX","horizontalMargin","verticalMargin","offset","maxY","viewWidth","maxX","viewHeight","horizontalSpace","generateOption","props","fits","sizeAvailable","sizeRequested","extraSpace","previousPlacement","geom","bestPlacementPosition","Object","keys","o","sort"],"sources":["/home/senac/Docks-mobile-P.I/node_modules/react-native-popover-view/src/Geometry.ts"],"sourcesContent":["import { StyleProp, ViewStyle } from 'react-native';\nimport { Rect, Size, Point, Placement, PopoverProps } from './Types';\nimport { getBorderRadius } from './Utility';\nimport { POPOVER_MARGIN } from './Constants';\n\ntype ComputeGeometryBaseProps = {\n  requestedContentSize: Size;\n  displayArea: Rect;\n  debug: (line: string, obj?: unknown) => void;\n  offset?: number;\n}\n\ntype ComputeGeometryProps = ComputeGeometryBaseProps & {\n  placement?: Placement | Array<Placement>;\n  previousPlacement?: Placement;\n  fromRect: Rect | null;\n  arrowSize: Size;\n  popoverStyle: StyleProp<ViewStyle>;\n  arrowShift?: number;\n  popoverShift?: PopoverProps['popoverShift'];\n}\n\ntype ComputeGeometryDirectionProps = ComputeGeometryBaseProps & {\n  fromRect: Rect;\n  arrowSize: Size;\n  borderRadius: number;\n  debug: (line: string, obj?: unknown) => void;\n}\n\ntype ComputeGeometryAutoProps = ComputeGeometryDirectionProps & {\n  previousPlacement?: Placement;\n};\n\nexport class Geometry {\n  popoverOrigin: Point;\n  anchorPoint: Point;\n  placement: Placement;\n  forcedContentSize: Size;\n  viewLargerThanDisplayArea: {\n    width: boolean,\n    height: boolean\n  }\n  constructor(\n    { popoverOrigin, anchorPoint, placement, forcedContentSize, viewLargerThanDisplayArea }:\n    {\n      popoverOrigin: Point;\n      anchorPoint: Point;\n      placement: Placement;\n      forcedContentSize: Size;\n      viewLargerThanDisplayArea: {\n        width: boolean,\n        height: boolean\n      }\n    }\n  ) {\n    this.popoverOrigin = popoverOrigin;\n    this.anchorPoint = anchorPoint;\n    this.placement = placement;\n    this.forcedContentSize = forcedContentSize;\n    this.viewLargerThanDisplayArea = viewLargerThanDisplayArea;\n  }\n  static equals(a: Geometry, b: Geometry): boolean {\n    return a.popoverOrigin.equals(b.popoverOrigin) &&\n      a.anchorPoint.equals(b.anchorPoint) &&\n      a.placement === b.placement &&\n      a.forcedContentSize.equals(b.forcedContentSize) &&\n      a.viewLargerThanDisplayArea?.width === b.viewLargerThanDisplayArea?.width &&\n      a.viewLargerThanDisplayArea?.height === b.viewLargerThanDisplayArea?.height;\n  }\n}\n\nexport function computeGeometry(options: ComputeGeometryProps): Geometry {\n  const {\n    requestedContentSize,\n    placement,\n    displayArea,\n    debug,\n    popoverStyle,\n    arrowShift,\n    popoverShift,\n    arrowSize\n  } = options;\n\n  let newGeom = null;\n\n  // Make copy so doesn't modify original\n  const fromRect = options.fromRect\n    ? Rect.clone(options.fromRect)\n    : null;\n  if (fromRect && options.fromRect instanceof Rect) {\n\n    const borderRadius = getBorderRadius(popoverStyle);\n\n    // Default to first option if given list of placements\n    let selectedPlacement = Array.isArray(placement) ? placement[0] : placement;\n\n    // If we can find a placement in the list that is better, use that\n    if (Array.isArray(placement)) {\n      const spaceList =\n        generateSpaceList({ fromRect, displayArea, requestedContentSize, arrowSize });\n      const bestPlacements = calculateBestPlacements(spaceList);\n      const [bestProvidedPlacement] = placement.\n        filter(p => p === Placement.AUTO || p === Placement.FLOATING || bestPlacements.includes(p));\n      if (bestProvidedPlacement) selectedPlacement = bestProvidedPlacement;\n    }\n\n    switch (selectedPlacement) {\n      case Placement.TOP:\n        newGeom = computeTopGeometry({ ...options, fromRect, borderRadius });\n        break;\n      case Placement.BOTTOM:\n        newGeom = computeBottomGeometry({ ...options, fromRect, borderRadius });\n        break;\n      case Placement.LEFT:\n        newGeom = computeLeftGeometry({ ...options, fromRect, borderRadius });\n        break;\n      case Placement.RIGHT:\n        newGeom = computeRightGeometry({ ...options, fromRect, borderRadius });\n        break;\n      case Placement.FLOATING:\n        newGeom = null;\n        break;\n      default:\n        newGeom = computeAutoGeometry({ ...options, fromRect, borderRadius });\n    }\n\n    debug('computeGeometry - initial chosen geometry', newGeom);\n\n    /*\n     * If the popover will be restricted and the view that the popover is showing\n     * from is sufficiently large, try to show the popover inside the view\n     */\n    if (\n      newGeom &&\n      (newGeom.viewLargerThanDisplayArea.width || newGeom.viewLargerThanDisplayArea.height)\n    ) {\n      const fromRectHeightVisible = fromRect.y < displayArea.y\n        ? fromRect.height - (displayArea.y - fromRect.y)\n        : displayArea.y + displayArea.height - fromRect.y;\n      if (\n        fromRect.width > requestedContentSize.width &&\n        fromRectHeightVisible > requestedContentSize.height\n      ) {\n        const preferredX = Math.max(\n          fromRect.x + 10, fromRect.x + ((fromRect.width - requestedContentSize.width) / 2)\n        );\n        const preferredY = Math.max(\n          fromRect.y + 10, fromRect.y + ((fromRect.height - requestedContentSize.height) / 2)\n        );\n\n        let constrainedX = Math.max(preferredX, displayArea.x);\n        if (constrainedX + requestedContentSize.width > displayArea.x + displayArea.width)\n          constrainedX = displayArea.x + displayArea.width - requestedContentSize.width;\n\n        let constrainedY = Math.max(preferredY, displayArea.y);\n        if (constrainedY + requestedContentSize.height > displayArea.y + displayArea.height)\n          constrainedY = displayArea.y + displayArea.height - requestedContentSize.height;\n\n        const forcedContentSize = new Size(\n          Math.min(fromRect.width - 20, displayArea.width),\n          Math.min(fromRect.height - 20, displayArea.height)\n        );\n\n        debug('computeGeometry - showing inside anchor');\n        newGeom = new Geometry({\n          popoverOrigin:\n            new Point(constrainedX, constrainedY),\n          anchorPoint:\n            new Point(fromRect.x + (fromRect.width / 2), fromRect.y + (fromRect.height / 2)),\n          placement: Placement.FLOATING,\n          forcedContentSize,\n          viewLargerThanDisplayArea: {\n            width: requestedContentSize.width > forcedContentSize.width,\n            height: requestedContentSize.height > forcedContentSize.height\n          }\n        });\n      } else if (\n        /*\n         * If we can't fit inside or outside the fromRect, show the popover floating on the screen,\n         *  but only do this if they haven't asked for a specifc placement type\n         *  and if it will actually help show more content\n         */\n        placement === Placement.AUTO &&\n        (\n          (\n            newGeom.viewLargerThanDisplayArea.width &&\n            [Placement.RIGHT, Placement.LEFT].includes(newGeom.placement)\n          ) ||\n          (\n            newGeom.viewLargerThanDisplayArea.height &&\n            [Placement.TOP, Placement.BOTTOM].includes(newGeom.placement)\n          )\n        )\n      ) {\n        newGeom = null;\n      }\n    }\n  }\n\n  if (!newGeom) {\n    const minY = displayArea.y;\n    const minX = displayArea.x;\n    const preferedY = ((displayArea.height - requestedContentSize.height) / 2) + displayArea.y;\n    const preferedX = ((displayArea.width - requestedContentSize.width) / 2) + displayArea.x;\n\n    debug('computeGeometry - showing floating');\n    newGeom = new Geometry({\n      popoverOrigin: new Point(Math.max(minX, preferedX), Math.max(minY, preferedY)),\n      anchorPoint: new Point(\n        (displayArea.width / 2) + displayArea.x,\n        (displayArea.height / 2) + displayArea.y\n      ),\n      placement: Placement.FLOATING,\n      forcedContentSize: new Size(displayArea.width, displayArea.height),\n      viewLargerThanDisplayArea: {\n        width: preferedX < minX - 1,\n        height: preferedY < minY - 1\n      }\n    });\n\n    // Apply popover shift\n    if (!newGeom.viewLargerThanDisplayArea.width && popoverShift?.x) {\n      debug('computeGeometry - applying popoverShift.x', popoverShift.x);\n      const horizontalMargin = (displayArea.width - requestedContentSize.width) / 2;\n      newGeom.popoverOrigin.x += popoverShift.x * horizontalMargin;\n      newGeom.anchorPoint.x = newGeom.popoverOrigin.x + (requestedContentSize.width / 2);\n    }\n    if (!newGeom.viewLargerThanDisplayArea.height && popoverShift?.y) {\n      debug('computeGeometry - applying popoverShift.y', popoverShift.y);\n      const verticalMargin = (displayArea.height - requestedContentSize.height) / 2;\n      newGeom.popoverOrigin.y += popoverShift.y * verticalMargin;\n      newGeom.anchorPoint.y = newGeom.popoverOrigin.y + (requestedContentSize.height / 2);\n    }\n  }\n\n  if (arrowShift && fromRect) {\n    if (newGeom.placement === Placement.BOTTOM || newGeom.placement === Placement.TOP)\n      newGeom.anchorPoint.x += arrowShift * 0.5 * fromRect.width;\n    else\n      newGeom.anchorPoint.y += arrowShift * 0.5 * fromRect.height;\n  }\n\n  debug('computeGeometry - final chosen geometry', newGeom);\n  return newGeom;\n}\n\nfunction computeTopGeometry({\n  displayArea,\n  fromRect,\n  requestedContentSize,\n  arrowSize,\n  borderRadius,\n  offset\n}: ComputeGeometryDirectionProps): Geometry {\n  // Apply a margin on non-arrow sides\n  displayArea = new Rect(\n    displayArea.x + POPOVER_MARGIN,\n    displayArea.y + POPOVER_MARGIN,\n    displayArea.width - (POPOVER_MARGIN * 2),\n    displayArea.height\n  );\n\n  if (offset) fromRect.y -= offset;\n\n  const minY = displayArea.y;\n  const maxY = displayArea.y + displayArea.height;\n  const preferredY = fromRect.y - requestedContentSize.height - arrowSize.height;\n\n  const forcedContentSize = new Size(\n    displayArea.width,\n    (fromRect.y - arrowSize.height - displayArea.y)\n  );\n\n  const viewLargerThanDisplayArea = {\n    height: preferredY <= minY - 1,\n    width: requestedContentSize.width >= displayArea.width + 1\n  };\n\n  const viewWidth = viewLargerThanDisplayArea.width\n    ? forcedContentSize.width\n    : requestedContentSize.width;\n\n  const maxX = displayArea.x + displayArea.width - viewWidth;\n  const minX = displayArea.x;\n  const preferredX = fromRect.x + ((fromRect.width - viewWidth) / 2);\n\n  const popoverOrigin = new Point(\n    Math.min(maxX, Math.max(minX, preferredX)),\n    Math.min(maxY, Math.max(minY, preferredY))\n  );\n\n  const anchorPoint = new Point(fromRect.x + (fromRect.width / 2), fromRect.y);\n\n  // Make sure the arrow isn't cut off\n  anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + (arrowSize.width / 2) + borderRadius);\n  anchorPoint.x = Math.min(\n    anchorPoint.x,\n    displayArea.x + displayArea.width - (arrowSize.width / 2) - borderRadius\n  );\n\n  return new Geometry({\n    popoverOrigin,\n    anchorPoint,\n    placement: Placement.TOP,\n    forcedContentSize,\n    viewLargerThanDisplayArea\n  });\n}\n\nfunction computeBottomGeometry({\n  displayArea,\n  fromRect,\n  requestedContentSize,\n  arrowSize,\n  borderRadius,\n  offset\n}: ComputeGeometryDirectionProps): Geometry {\n  // Apply a margin on non-arrow sides\n  displayArea = new Rect(\n    displayArea.x + POPOVER_MARGIN,\n    displayArea.y,\n    displayArea.width - (POPOVER_MARGIN * 2),\n    displayArea.height - POPOVER_MARGIN\n  );\n\n  if (offset) fromRect.y += offset;\n\n  const minY = displayArea.y;\n  const maxY = displayArea.y + displayArea.height;\n  const preferedY = fromRect.y + fromRect.height;\n\n  const forcedContentSize = new Size(\n    displayArea.width,\n    displayArea.y + displayArea.height - preferedY\n  );\n\n  const viewLargerThanDisplayArea = {\n    height: preferedY + requestedContentSize.height >= displayArea.y + displayArea.height + 1,\n    width: requestedContentSize.width >= displayArea.width + 1\n  };\n\n  const viewWidth = viewLargerThanDisplayArea.width\n    ? forcedContentSize.width\n    : requestedContentSize.width;\n\n  const maxX = displayArea.x + displayArea.width - viewWidth;\n  const minX = displayArea.x;\n  const preferedX = fromRect.x + ((fromRect.width - viewWidth) / 2);\n\n  const popoverOrigin = new Point(\n    Math.min(maxX, Math.max(minX, preferedX)),\n    Math.min(maxY, Math.max(minY, preferedY))\n  );\n\n  const anchorPoint = new Point(fromRect.x + (fromRect.width / 2), fromRect.y + fromRect.height);\n\n  // Make sure the arrow isn't cut off\n  anchorPoint.x = Math.max(anchorPoint.x, popoverOrigin.x + (arrowSize.width / 2) + borderRadius);\n  anchorPoint.x = Math.min(\n    anchorPoint.x,\n    displayArea.x + displayArea.width - (arrowSize.width / 2) - borderRadius\n  );\n\n  return new Geometry({\n    popoverOrigin,\n    anchorPoint,\n    placement: Placement.BOTTOM,\n    forcedContentSize,\n    viewLargerThanDisplayArea\n  });\n}\n\nfunction computeLeftGeometry({\n  displayArea,\n  fromRect,\n  requestedContentSize,\n  borderRadius,\n  arrowSize,\n  offset\n}: ComputeGeometryDirectionProps): Geometry {\n  // Apply a margin on non-arrow sides\n  displayArea = new Rect(\n    displayArea.x + POPOVER_MARGIN,\n    displayArea.y + POPOVER_MARGIN,\n    displayArea.width,\n    displayArea.height - (POPOVER_MARGIN * 2)\n  );\n\n  if (offset) fromRect.x -= offset;\n\n  const forcedContentSize = new Size(\n    fromRect.x - displayArea.x - arrowSize.width,\n    displayArea.height\n  );\n\n  const viewLargerThanDisplayArea = {\n    height: requestedContentSize.height >= displayArea.height + 1,\n    width: requestedContentSize.width >= fromRect.x - displayArea.x - arrowSize.width + 1\n  };\n\n  const viewWidth = viewLargerThanDisplayArea.width\n    ? forcedContentSize.width\n    : requestedContentSize.width;\n  const viewHeight = viewLargerThanDisplayArea.height\n    ? forcedContentSize.height\n    : requestedContentSize.height;\n\n  const preferedX = fromRect.x - viewWidth - arrowSize.height;\n  const minX = displayArea.x;\n  const maxX = displayArea.x + displayArea.width;\n\n  const preferedY = fromRect.y + ((fromRect.height - viewHeight) / 2);\n  const minY = displayArea.y;\n  const maxY = (displayArea.height - viewHeight) + displayArea.y;\n\n  const popoverOrigin = new Point(\n    Math.min(Math.max(minX, preferedX), maxX),\n    Math.min(Math.max(minY, preferedY), maxY)\n  );\n\n  const anchorPoint = new Point(fromRect.x, fromRect.y + (fromRect.height / 2));\n\n  // Make sure the arrow isn't cut off\n  anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + (arrowSize.height / 2) + borderRadius);\n  anchorPoint.y = Math.min(\n    anchorPoint.y,\n    displayArea.y + displayArea.height - (arrowSize.height / 2) - borderRadius\n  );\n\n  return new Geometry({\n    popoverOrigin,\n    anchorPoint,\n    placement: Placement.LEFT,\n    forcedContentSize,\n    viewLargerThanDisplayArea\n  });\n}\n\nfunction computeRightGeometry({\n  displayArea,\n  fromRect,\n  requestedContentSize,\n  arrowSize,\n  borderRadius,\n  offset\n}: ComputeGeometryDirectionProps): Geometry {\n  // Apply a margin on non-arrow sides\n  displayArea = new Rect(\n    displayArea.x,\n    displayArea.y + POPOVER_MARGIN,\n    displayArea.width - POPOVER_MARGIN,\n    displayArea.height - (POPOVER_MARGIN * 2)\n  );\n\n  if (offset) fromRect.x += offset;\n\n  const horizontalSpace =\n    displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width;\n\n  const forcedContentSize = new Size(\n    horizontalSpace,\n    displayArea.height\n  );\n\n  const viewLargerThanDisplayArea = {\n    height: requestedContentSize.height >= displayArea.height + 1,\n    width: requestedContentSize.width >= horizontalSpace + 1\n  };\n\n  const viewHeight = viewLargerThanDisplayArea.height\n    ? forcedContentSize.height\n    : requestedContentSize.height;\n\n  const preferedX = fromRect.x + fromRect.width;\n  const minX = displayArea.x;\n  const maxX = displayArea.x + displayArea.width;\n\n  const preferedY = fromRect.y + ((fromRect.height - viewHeight) / 2);\n  const minY = displayArea.y;\n  const maxY = (displayArea.height - viewHeight) + displayArea.y;\n\n  const popoverOrigin = new Point(\n    Math.min(Math.max(minX, preferedX), maxX),\n    Math.min(Math.max(minY, preferedY), maxY)\n  );\n\n  const anchorPoint = new Point(fromRect.x + fromRect.width, fromRect.y + (fromRect.height / 2.0));\n\n  // Make sure the arrow isn't cut off\n  anchorPoint.y = Math.max(anchorPoint.y, popoverOrigin.y + (arrowSize.height / 2) + borderRadius);\n  anchorPoint.y = Math.min(\n    anchorPoint.y,\n    displayArea.y + displayArea.height - (arrowSize.height / 2) - borderRadius\n  );\n\n  return new Geometry({\n    popoverOrigin,\n    anchorPoint,\n    placement: Placement.RIGHT,\n    forcedContentSize,\n    viewLargerThanDisplayArea\n  });\n}\n\ntype PlacementOption = {\n  sizeRequested: number;\n  sizeAvailable: number;\n  fits: boolean;\n  extraSpace: number;\n}\ntype SpaceList = Partial<Record<Placement, PlacementOption>>\ntype SpaceListProps = Pick<ComputeGeometryDirectionProps, 'fromRect' | 'displayArea' | 'arrowSize' | 'requestedContentSize'>;\nfunction generateSpaceList({\n  fromRect,\n  displayArea,\n  arrowSize,\n  requestedContentSize\n}: SpaceListProps): SpaceList {\n  function generateOption(props: Pick<PlacementOption, 'sizeRequested' | 'sizeAvailable'>): PlacementOption {\n    return {\n      ...props,\n      fits: props.sizeAvailable >= props.sizeRequested,\n      extraSpace: props.sizeAvailable - props.sizeRequested\n    };\n  }\n  return {\n    [Placement.LEFT]: generateOption({\n      sizeAvailable: fromRect.x - displayArea.x - arrowSize.width,\n      sizeRequested: requestedContentSize.width\n    }),\n    [Placement.RIGHT]: generateOption({\n      sizeAvailable:\n        displayArea.x + displayArea.width - (fromRect.x + fromRect.width) - arrowSize.width,\n      sizeRequested: requestedContentSize.width\n    }),\n    [Placement.TOP]: generateOption({\n      sizeAvailable: fromRect.y - displayArea.y - arrowSize.width,\n      sizeRequested: requestedContentSize.height\n    }),\n    [Placement.BOTTOM]: generateOption({\n      sizeAvailable:\n        displayArea.y + displayArea.height - (fromRect.y + fromRect.height) - arrowSize.width,\n      sizeRequested: requestedContentSize.height\n    })\n  };\n}\n\nfunction computeAutoGeometry(options: ComputeGeometryAutoProps): Geometry | null {\n  const {\n    displayArea,\n    requestedContentSize,\n    fromRect,\n    previousPlacement,\n    debug,\n    arrowSize\n  } = options;\n\n  // Keep same placement if possible (left/right)\n  if (previousPlacement === Placement.LEFT || previousPlacement === Placement.RIGHT) {\n    const geom = previousPlacement === Placement.LEFT\n      ? computeLeftGeometry(options)\n      : computeRightGeometry(options);\n    debug('computeAutoGeometry - Left/right tryping to keep same, geometry', geom);\n    if (!geom.viewLargerThanDisplayArea.width) return geom;\n  }\n\n  // Keep same placement if possible (top/bottom)\n  if (previousPlacement === Placement.TOP || previousPlacement === Placement.BOTTOM) {\n    const geom = previousPlacement === Placement.TOP\n      ? computeTopGeometry(options)\n      : computeBottomGeometry(options);\n    debug('computeAutoGeometry - Top/bottom tryping to keep same, geometry', geom);\n    if (!geom.viewLargerThanDisplayArea.height) return geom;\n  }\n\n  /*\n   * Otherwise, find the place that can fit it best (try left/right but\n   * default to top/bottom as that will typically have more space)\n   */\n\n  // generating list of all possible sides with validity\n  debug('computeAutoGeometry - displayArea', displayArea);\n  debug('computeAutoGeometry - fromRect', fromRect);\n\n  const spaceList = generateSpaceList({ fromRect, displayArea, arrowSize, requestedContentSize });\n  debug('computeAutoGeometry - List of available space', spaceList);\n\n  const [bestPlacementPosition] = calculateBestPlacements(spaceList);\n  debug('computeAutoGeometry - Found best postition for placement', bestPlacementPosition);\n\n  switch (bestPlacementPosition) {\n    case Placement.LEFT: return computeLeftGeometry(options);\n    case Placement.RIGHT: return computeRightGeometry(options);\n    case Placement.BOTTOM: return computeBottomGeometry(options);\n    case Placement.TOP: return computeTopGeometry(options);\n    // Return nothing so popover will be placed in middle of screen\n    default: return null;\n  }\n}\n\nfunction calculateBestPlacements(spaceList: SpaceList): Placement[] {\n  return (Object.keys(spaceList) as Placement[]).filter(\n    o => spaceList[o]?.fits\n  ).sort((a, b) => (spaceList[b]?.extraSpace ?? 0) - (spaceList[a]?.extraSpace ?? 0));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}